package com.tikelespike.nilee.app.views.character.sheet.dice;

import com.tikelespike.nilee.core.dice.DiceExpression;
import com.tikelespike.nilee.core.game.RollEvent;
import com.tikelespike.nilee.core.i18n.TranslationProvider;
import com.vaadin.flow.component.Component;
import com.vaadin.flow.component.Text;
import com.vaadin.flow.component.avatar.Avatar;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.H5;
import com.vaadin.flow.component.html.Hr;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.server.StreamResource;
import jakarta.validation.constraints.NotNull;

import java.io.ByteArrayInputStream;
import java.util.Objects;

/**
 * The result of a dice roll, including the steps made to calculate the result. Can generate a Vaadin layout to display
 * the result and its calculation.
 * <p>
 * Wraps around a {@link RollEvent} to provide UI components for displaying the result of the roll.
 */
public class RollResult {

    private final RollEvent rollEvent;
    private final TranslationProvider translationProvider;

    /**
     * Creates a new roll result.
     *
     * @param rollEvent the roll event containing details about the roll
     * @param translationProvider translation provider to use for translating the UI components generated by
     *         this
     *
     * @throws IllegalArgumentException if the computation steps are empty
     */
    public RollResult(RollEvent rollEvent, @NotNull TranslationProvider translationProvider) {
        this.rollEvent = rollEvent;
        this.translationProvider = Objects.requireNonNull(translationProvider);
    }

    /**
     * Creates a vaadin layout that shows what was rolled for, all steps to calculate the result, and the result
     * itself.
     *
     * @return a Vaadin layout that displays the result and its calculation
     */
    public Component getDetailedLayout() {
        VerticalLayout resultLayout = new VerticalLayout();

        addHeader(resultLayout);

        for (int i = 1; i < rollEvent.getComputationSteps().length - 1; i++) {
            addPartialResult(resultLayout, rollEvent.getComputationSteps()[i]);
        }

        addResult(resultLayout, rollEvent.getComputationSteps()[rollEvent.getComputationSteps().length - 1]);

        return resultLayout;
    }

    /**
     * Creates a vaadin layout that shows what was rolled for and the result itself, in a compact format.
     *
     * @return a vaadin layout showing the result of the roll in a compact form
     */
    public Component getCompactLayout() {
        String rollString = rollEvent.getDescription().getTranslation(translationProvider);
        String resultString =
                rollEvent.getComputationSteps()[rollEvent.getComputationSteps().length - 1].toLocalizedString()
                        .getTranslation(translationProvider);
        Span description = new Span(rollString + ":");
        Span result = new Span(resultString);
        result.getStyle().set("font-weight", "bold");
        HorizontalLayout resultLayout = new HorizontalLayout(getAvatar(), description, result);
        resultLayout.expand(description);
        resultLayout.getStyle().set("font-size", "var(--lumo-font-size-xl)");
        return resultLayout;
    }

    private void addHeader(VerticalLayout resultLayout) {
        H3 headline = new H3(rollEvent.getDescription().getTranslation(translationProvider));
        Avatar avatar = getAvatar();

        Div avatarWrapper = new Div(avatar);
        avatarWrapper.getStyle().set("padding-right", "var(--lumo-space-m)");

        String author = rollEvent.getCharacterRolling() == null ? rollEvent.getUserRolling().getName()
                : rollEvent.getCharacterRolling().getName();
        H5 subHeadline = new H5(translationProvider.translate("character_sheet.dice.roll_source", author));

        VerticalLayout titleTextLines = new VerticalLayout(headline, subHeadline);

        HorizontalLayout firstLine = new HorizontalLayout(avatar, titleTextLines);
        firstLine.setDefaultVerticalComponentAlignment(FlexComponent.Alignment.CENTER);

        HorizontalLayout rollDescriptor = createRollDescriptor(rollEvent.getComputationSteps()[0]);

        resultLayout.add(firstLine, rollDescriptor, new Hr());
    }

    private Avatar getAvatar() {
        Avatar avatar = new Avatar(rollEvent.getUserRolling().getName());
        StreamResource resource = new StreamResource("profile-pic",
                () -> new ByteArrayInputStream(rollEvent.getUserRolling().getProfilePicture()));
        avatar.setImageResource(resource);
        return avatar;
    }

    private void addResult(VerticalLayout resultLayout, DiceExpression result) {
        String resultString = result.toLocalizedString().getTranslation(translationProvider);
        Div resultText = new Div(new Text("= " + resultString));
        resultText.getStyle().set("font-size", "var(--lumo-font-size-xxxl)");
        resultLayout.add(resultText);
        resultLayout.setHorizontalComponentAlignment(FlexComponent.Alignment.END, resultText);
    }

    private void addPartialResult(VerticalLayout resultLayout, DiceExpression partialResult) {
        String partialString = partialResult.toLocalizedString().getTranslation(translationProvider);
        Div partialText = new Div(new Text("= " + partialString));
        resultLayout.add(partialText);
        resultLayout.setHorizontalComponentAlignment(FlexComponent.Alignment.END, partialText);
    }

    private HorizontalLayout createRollDescriptor(DiceExpression roll) {
        Icon icon = new Icon(VaadinIcon.CUBE);
        String rollString = roll.toLocalizedString().getTranslation(translationProvider);
        return new HorizontalLayout(icon, new Text(rollString));
    }
}
